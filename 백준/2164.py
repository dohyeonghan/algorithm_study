'''사용할 자료구조
- 배열 -> 바로 쓸게 아니라 시간복잡도 따져봐야함
- 정수 N ( 1<= N <= 500000)
- 생각한 로직으로 짰을때 복잡도 상의 문제가 없는지 생각해봐야함

로직 
1. 맨앞의 값을 삭제 
2. 맨앞의 값을 맨뒤로 보내기 -> 맨앞의 값 삭제, 맨앞의 값 맨뒤에 삽입

배열에서 삽입 삭제의 시간복잡도? -> O(N) (worst)
-> 삽입 삭제시 나머지 값들을 다 하나씩 밀거나 당기거나 해줘야하므로 
1,2번 행하면 N 에서 N-1됨 
즉 1개남을때까지 1,2번을 N-1번 행해줘야함 1, 2번은 삽입삭제를 총 3번
(N-1) * 3 * O(N)
-> O(n^2) 500000^2?? -> 안됨

-큐를 이용 (삽입삭제 O(1))
-빼는건 앞에서만, 삽입은 뒤에서만
deque
'''

from collections import deque

dq = deque()
N = int(input())
for i in range(1, N + 1):
    dq.append(i)
'''선언할때 바로 넣는 방법
deque(range(1, N+1))'''

'''카드 한장 남을때까지 반복'''
while len(dq) > 1:
  dq.popleft()
  dq.append(dq.popleft())
#마지막값 출력
print(dq.popleft())